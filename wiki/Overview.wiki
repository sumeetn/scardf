#summary Overview of DSL features of Scardf

Basic use cases of the API are:
 * Defining RDF *vocabularies*
 * *Building* RDF graphs
 * *Traversing* RDF graphs
 * *Querying* RDF graphs

== Defining a vocabulary ==

{{{
object PeopleVocabulary extends Vocabulary( "person:" ) {
  val Person = pRes( "Person" )
  val Name = pProp( "Name" )
  val Given = pProp( "Given" )
  val Family = pProp( "Family" )
  val Birthday = pProp( "Birthday" )
  val IsMale = pProp( "IsMale" )
  val Height = pProp( "Height" )
  val Likes = pProp( "Likes" )
  val Swimming = pRes( "Swimming" )
  val Science = pRes( "Science" )
  val Spouse = pProp( "Spouse" )
}
}}}

== Building a graph ==

{{{
implicit val model = new RModel withPrefix "example:"
import PeopleVocabulary._
val jdoe = Res( "jdoe" ) a Person state(
  Name -> Anon(
    Given -> "John",
    Family -> "Doe"
  ),
  Birthday -> "1977-07-27",
  Height -> 167,
  IsMale -> true,
  Likes -> Swimming,
  Likes -> Science
)
}}}

== Traversing a graph ==

A graph can be [Traversal traversed] with a slash operator forming XPath-like expressions:
{{{
jdoe/Name/Given
}}}

These yield a sequence of RDF node objects. To convert a node list to a string, you use the same slash operator, but now with a converter:
{{{
jdoe/Name/Given/asString == "John"
}}}


== Querying a graph ==

{{{
val x = new QVar
Sparql selectRes x where( (x, Height, 167) ) from model == Some( jdoe )
}}}