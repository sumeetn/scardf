#summary Overview of DSL features of Scardf

= Introduction =

Basic use cases of the API are:
 * Defining RDF *vocabularies*
 * *Building* RDF graphs
 * *Traversing* RDF graphs
 * *Querying* RDF graphs


== Defining a vocabulary ==

{{{
object ExampleVocabulary extends Vocabulary( "http://example.org#" ) {
  val rClass = pRes( "Class" )
  val rInstance = pRes( "Instance" ) a rClass
  val pTitle = pProp( "title" )
}
}}}

== Building a graph ==

{{{
implicit val model = new RModel withPrefix "http://example.org/no2#"
import com.hp.hpl.jena.vocabulary.VCARD._
val john = Res( "jsmith" ) state(
  FN -> "John Smith",
  N -> Anon(
    Given -> "John",
    Family -> "Smith"
  ),
  BDAY -> "1977-07-27"
)
}}}

== Traversing a graph ==

Reading a property from a RDF resource is simple:
{{{
  N valueOf john
}}}

But a more readable way is with a slash operator, like in XPath. You can even stack the properties to form a path:
{{{
  john/N/Given
}}}

But this actually gives you a sequence of RDF node objects, which may be empty, or a single node, or multiple nodes. To convert a node list to a string, you use the same slash operator, but now with a converter:
{{{
  john/N/Given/asString == "John"
}}}

Of course, this would only work if the node list contains a single node, a literal convertible to string.

You can use more converters:
{{{
  john/BDAY/asLocalDate == new LocalDate( 1975, 5, 27 )
}}}

Another type you can use with a slash operator is a language extractor, useful for multilingual literals:
{{{
  john/title/Lang.en
}}}

== Querying a graph ==

{{{
  val x = new QVar
  val entryResQ = Sparql selectRes x where( (x, title, "Overview") )
}}}