#summary Overview of DSL features of Scardf
#labels Featured

Basic use cases of the API are:
 * Defining RDF *vocabularies*
 * *Building* RDF graphs
 * *Traversing* RDF graphs
 * *Querying* RDF graphs

== Defining a [Vocabulary vocabulary] ==

You can define values in an `object` to define your vocabulary and the basic ontology:
{{{
object PeopleVocabulary extends Vocabulary( "http://person.eg#" ) {
  val Person = pRes( "Person" )
  val Hobby = pRes( "Hobby" )
  val Swimming = pRes( "Swimming" ) a Hobby
  val Science = pRes( "Science" ) a Hobby
  val Likes = pProp( "Likes" ) withRange Hobby
  val IsMale = pProp( "IsMale" ) withRange XSD.boolean
  val Height = pProp( "Height" ) withRange XSD.int
}
}}}

== [Building] a graph ==

You can add statements to the model using 
{{{
Height( john ) = 167
john state( IsMale -> true, Likes -> (Swimming, Science) )
}}}

An RDF graph is constructed using nested expressions:
{{{
implicit val model = new Model withPrefix "http://family.eg#"
val john = Res( "john" ) a Person state(
  Name -> Anon( Given -> "John", Family -> "Doe" ),
  IsMale -> true,
  Height -> 167,
  Likes -> ( Swimming, Science )
)
}}}

== [Traversal Traversing] a graph ==

A graph can be traversed with a slash operator forming an XPath-like expressions:
{{{
john/Name/Given
}}}

These yield a bag of RDF node objects. If you expect a single string, you append the `asString` converter object:
{{{
john/Name/Given/asString == "John"
}}}

Converters also have modifiers which yield collections of Scala objects:
{{{
john/Likes/asRes.set == Set( Swimming, Science )
}}}

== [Querying] a graph ==

{{{
val x = new QVar
val query = Sparql select x where( (x, Height, 167) )
val results = query from model
}}}

The query object forms a Sparql query string:
{{{
SELECT ?v1 WHERE { ?v1 <person:Height> 167. }
}}}

Query executed on the example model yields a single result with resource `http://family.eg#john`
