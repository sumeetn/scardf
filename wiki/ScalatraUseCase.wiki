#labels Deprecated
Use scardf features to publish a RESTfull data retrieval API for a RDF datastore. 

As data we will use a popular example of a periodic table of elements at http://www.daml.org/2003/01/periodictable/PeriodicTable

Let's say we have loaded this graph in a SPARQL-enabled graph through the val `dataGraph`.


== Listing all chemical elements ==

Scalatra rules are in the form _method_(_path_)
{{{
get("/elements") {
  val elements = findAll( fc -( RDF.Type -> rElement ) )
  val content = listContent( elements, elementSummaryPT )
  uriAugmenter augmented content
}
}}}

=== Step 1: Finding the focus nodes in the data graph ===

{{{
val fc = Blank()

def findAll( branches: Branch* ) =
  TemplateFactory( fc -> QVar() )( Graph( branches: _* ) ).findAllIn( dataGraph )
}}}

We can use this method to fetch a list of all elements in the data graph:
{{{
val elements = findAll( fc -( RDF.Type -> rElement ) )
}}}

=== Step 2: Expanding the selection ===

For every using predicates RDF type, symbol, name and atomic number. 
{{{
val elementSummaryPT = PredicateTree( RDF.Type, symbol, name, atomicNumber )
}}}

Expanding the selection of a single node using a predicate tree is achieved with the `CONSTRUCT` statement:
{{{
def content( pt: PredicateTree, anchor: Node ) =
  dataGraph.construct( pt buildPatternBlock anchor construct )
}}}

{{{
def listContent( items: List[Node], pt: PredicateTree ) =
  items.map{ content( pt, _ ).triples }.foldLeft( new JenaGraph ){ _++_ }
}}}

=== Augmenting the content ===

{{{
  val uriAugmenter = 
    Augment add { e =>
      e/RDF.Type.v match {
        case Per.rElement => p -href-> ("/e/" + p/symbol.v)
        case _ => Branch( p )
      }
    } forEach { _/-/having( RDF.Type ) }
}}}  


=== Response format ===

Of course, the resulting graphs should be serialized into an appropriate format, like Turtle. So we override Scalatra's `renderResponseBody` method:
{{{
override protected def renderResponseBody( actionResult: Any ) =
  super.renderResponseBody( 
    actionResult match {
      case g: Graph => g renderIn Turtle asString
      case other => other
    }
  )
}}}


== Single element == 


{{{
get("/e/:symbol") {
  val e = findOne( fc -( RDF.Type -> rElement, symbol -> params("symbol") ) )
  uriAugmenter augmented singleContent( elementDetailedPT, e )
}
}}}

=== Locating a single element in graph ===

This way, unknown symbols will result in a `404 (Not Found)` response.
{{{
def findOne( branches: Branch* ) =
  findAll( branches: _* ) match {
    case Nil => halt( 404 )
    case List( one ) => one
    case x => halt( 500, "Not unique, resulted in: " + x )
  }
}}}

=== Extended predicate trees ===

Additional predicates are a part of a _detailed_ element predicate trees:
{{{
val elementDetailedPT = elementSummaryPT ++ 
  PredicateTree( color?, standardState, classification, atomicWeight, period )
}}}
